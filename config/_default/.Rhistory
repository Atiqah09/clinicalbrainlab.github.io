"RQA (VEn)" = "#4CAF50",
"RQA (W)" = "#4CAF50",
"RQA (WMax)" = "#4CAF50",
"RQA (WEn)" = "#4CAF50",
"DFA" = "#4CAF50",
"MFDFA (Fluctuation)" = "#4CAF50",
"MFDFA (Width)" = "#4CAF50",
"MFDFA (Peak)" = "#4CAF50",
"MFDFA (Mean)" = "#4CAF50",
"MFDFA (Max)" = "#4CAF50",
"MFDFA (Delta)" = "#4CAF50",
"MFDFA (Asymmetry)" = "#4CAF50",
"MFDFA (Increment)" = "#4CAF50"
)
# length(unique(df$Index))
# unique(df$Index)[!unique(df$Index) %in% names(colors)]
# names(colors)[!names(colors) %in% unique(df$Index)]
# Chunk 4
order <- df |>
group_by(Index) |>
summarize(Duration = median(Duration)) |>
arrange(Duration) |>
mutate(Index = factor(Index, levels = Index))
df <- mutate(df, Index = fct_relevel(Index, as.character(order$Index)))
# Chunk 9
# Show and filter out NaNs
as.character(df[is.na(df$Result), "Index"])
df <- filter(df, !is.na(Result))
as.character(df[is.infinite(df$Result), "Index"])
df <- filter(df, !is.infinite(Result))
df <- df |>
group_by(Index) |>
standardize(select = "Result") |>
ungroup()
# Chunk 10
data <- df |>
mutate(i = paste(Signal, Length, Noise_Type, Noise_Intensity, sep = "__")) |>
select(i, Index, Result) |>
pivot_wider(names_from = "Index", values_from = "Result") |>
select(-i)
# pca <- principal_components(data, n=1) |>
#   arrange(desc(sign(PC1)), desc(abs(PC1)))
get_cor <- function(data, plot=FALSE) {
cor <- correlation::correlation(data, method = "pearson", redundant = TRUE) |>
correlation::cor_sort(hclust_method = "ward.D2")
if(plot) {
p_data <- cor |>
cor_lower() |>
mutate(
Text = insight::format_value(r, zap_small = TRUE, digits = 3),
Text = str_replace(str_remove(Text, "^0+"), "^-0+", "-"),
Parameter2 = fct_rev(Parameter2)
)
p <- p_data |>
ggplot(aes(x = Parameter2, y = Parameter1)) +
geom_tile(aes(fill = r)) +
# geom_text(aes(label = Text), size = 2) +
scale_fill_gradient2(low = "#2196F3", mid = "white", high = "#F44336", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation", guide = "legend") +
scale_x_discrete(expand = c(0, 0)) +
scale_y_discrete(expand = c(0, 0)) +
labs(title = "Correlation Matrix of Complexity Indices", x = NULL, y = NULL) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
plot.title = element_text(hjust = 0.5, face="bold"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
plot(p)
}
cor
}
cor <- get_cor(data)
# Chunk 11
cor |>
cor_lower() |>
filter(Parameter1 %in% names(data), Parameter2 %in% names(data)) |>
arrange(desc(abs(r)), Parameter1) |>
filter(Parameter1 != Parameter2) |>
filter(abs(r) > .97) |>
select(Parameter1, Parameter2, r)
# Chunk 13: correlation
data <- data |>
select(
-`FuzzyRCMSEn`,
-`CREn (100)`,
-`PowEn`
)
cor <- get_cor(data, plot=TRUE)
# Chunk 14
r <- correlation::cor_smooth(as.matrix(cor))
# Chunk 15: nfactors
n <- parameters::n_factors(data, cor = r, n_max=20)
n
plot(n) +
see::theme_modern()
# Chunk 16: loadings
rez <- parameters::factor_analysis(data, cor = r, n = 14, rotation = "varimax", sort = TRUE, fm="mle")
# rez <- parameters::principal_components(data, n = 15, sort = TRUE)
# rez
col <- gsub('[[:digit:]]+', '', names(rez)[2])
closest <- colnames(select(rez, starts_with(col)))[apply(select(rez, starts_with(col)), 1, \(x) which.max(abs(x)))]
loadings <- attributes(rez)$loadings_long |>
mutate(
Loading = Loading,
Component = fct_relevel(Component, rev(names(select(rez, starts_with(col))))),
Variable = fct_rev(fct_relevel(Variable, rez$Variable))
)
colors <- setNames(see::palette_material("rainbow")(length(levels(loadings$Component))), levels(loadings$Component))
# Sort by sign too
names(closest) <- rev(levels(loadings$Variable))
idx_order <- loadings |>
mutate(Closest = closest[as.character(loadings$Variable)],
Sign = sign(Loading)) |>
filter(Component == Closest) |>
arrange(desc(Component), desc(Sign), desc(abs(Loading))) |>
pull(Variable) |>
as.character()
separations <- table(closest)[intersect(levels(loadings$Component), unique(closest))]
selection <- c("ShanEn (D)",
"NLDFD",
"SVDEn",
"AttEn",
"PSDFD",
"MFDFA (Mean)",
"FuzzyMSEn",
"MSWPEn",
"MFDFA (Increment)",
"ShanEn (r)",
"Hjorth",
"WPEn")
face <- rep("plain", length(idx_order))
face[idx_order %in% c("SD", "Length", "Noise", "Random", "Frequency")] <- "italic"
face[idx_order %in% selection] <- "bold"
p1 <- loadings |>
mutate(Variable = fct_relevel(Variable, rev(idx_order))) |>
ggplot(aes(x = Variable, y = Loading)) +
geom_bar(aes(fill = Component), stat = "identity") +
geom_vline(xintercept = c("SD", "Length", "Noise", "Random"), color = "red") +
geom_vline(xintercept = head(cumsum(separations), -1) + 0.5) +
scale_y_continuous(expand = c(0, 0)) +
scale_fill_material_d("rainbow") +
coord_flip() +
theme_minimal() +
guides(fill = guide_legend(reverse = TRUE)) +
labs(x = NULL) +
theme(
axis.text.y = element_text(
color = rev(colors[closest]),
face = rev(face),
hjust = 0.5
),
axis.text.x = element_blank(),
plot.title = element_text(hjust = 0.5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
p2 <- order |>
mutate(Duration = 1 + Duration * 10000) |>
filter(Index %in% loadings$Variable) |>
mutate(Index = fct_relevel(Index, rev(idx_order)),
Duration = ifelse(is.na(Duration), 0, Duration)) |>
ggplot(aes(x = log10(Duration), y = Index)) +
geom_bar(aes(fill = log10(Duration)), stat = "identity") +
geom_hline(yintercept = head(cumsum(separations), -1) + 0.5) +
scale_x_reverse(expand = c(0, 0)) +
scale_y_discrete(position = "right") +
scale_fill_viridis_c(guide = "none") +
labs(x = "Computation Time", y = NULL) +
theme_minimal() +
theme(
axis.text.y = element_blank(),
axis.text.x = element_blank(),
plot.title = element_text(hjust = 0.5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
(p2 | p1) + patchwork::plot_annotation(title = "Computation Time and Factor Loading", theme = theme(plot.title = element_text(hjust = 0.5, face = "bold")))
# Chunk 17: ggm
library(ggraph)
extrafont::loadfonts()
g <- cor |>
cor_lower() |>
mutate(width = abs(r),
edgecolor = as.character(sign(r))) |>
filter(!Parameter1 %in% c("SD", "Length", "Random", "Frequency", "Noise"),
!Parameter2 %in% c("SD", "Length", "Random", "Frequency", "Noise")) |>
tidygraph::as_tbl_graph(directed=FALSE) |>
mutate(importance = tidygraph::centrality_authority(weights = abs(r)),
group = as.factor(tidygraph::group_louvain(weights = abs(r)))) |>
tidygraph::activate("edges") |>
filter(abs(r) > 0.6) |>
tidygraph::activate("nodes") |>
filter(!tidygraph::node_is_isolated()) |>
mutate(colors = closest[name],
selection = ifelse(name %in% selection, TRUE, FALSE))
p1 <- g |>
ggraph(layout = 'linear', circular = TRUE) +  # fr # lgl # drl # kk
ggraph::geom_edge_arc(aes(edge_width=width, edge_colour=edgecolor), alpha=0.66, strength=0.3) +
# ggraph::geom_conn_bundle(aes(edge_width=width, edge_colour=edgecolor), alpha=0.66) +
ggraph::geom_node_point(aes(size = importance)) +
ggraph::geom_node_text(aes(x = x*1.05, y=y*1.05, label = name, angle = -((-node_angle(x, y)+90)%%180)+90, hjust='outward', color=selection)) +
scale_edge_color_manual(values = c("1" = "#2E7D32", "-1"="#C62828"), guide = "none") +
scale_edge_width_continuous(range = c(0.005, 0.66), guide = "none") +
scale_size_continuous(range = c(0.1, 2), guide = "none") +
scale_fill_material_d(guide= "none") +
scale_colour_manual(values=c("TRUE" = "red", "FALSE"="black"), guide= "none") +
ggtitle("Correlation Network") +
ggraph::theme_graph() +
theme(plot.title = element_text(face="bold", hjust=0.5)) +
expand_limits(x = c(-1.25, 1.25), y = c(-1.25, 1.25))
p1
# Chunk 18: clustering
clust <- data |>
select(-SD, -Length, -Random, -Frequency, -Noise) |>
t() |>
as.data.frame() |>
dist() |>
hclust(method = "ward.D2")
clusters <- cutree(clust, h = 150)
colors <- c("red", "black", see::palette_material("rainbow")(max(clusters)))
names(colors) <- c("TRUE", "FALSE", seq(1:max(clusters)))
dat <- clust |>
create_layout(layout = 'dendrogram', circular = TRUE, repel=TRUE) |>
attr("graph") |>
tidygraph::activate("nodes") |>
mutate(colors = closest[label],
selection = ifelse(label %in% selection, TRUE, FALSE),
cluster = as.factor(clusters[label]))
p2 <- dat |>
tidygraph::activate("edges") |>
mutate(height = as.data.frame(dat)$height[from]) |>
ggraph(layout = 'dendrogram', circular = TRUE, repel=TRUE) +
geom_edge_elbow(aes(edge_width = height)) +
geom_node_point(aes(filter=leaf, color = cluster), size=3) +
geom_node_text(aes(x = x*1.05, y=y*1.05, label = label, angle = -((-node_angle(x, y)+90)%%180)+90, hjust='outward', color = selection)) +
scale_colour_manual(values=colors, guide= "none") +
scale_edge_width_continuous(range=c(1, 1.15), guide= "none") +
coord_fixed() +
ggtitle("Hierarchical Clustering") +
theme_graph() +
theme(plot.title = element_text(face="bold", hjust=0.5)) +
expand_limits(x = c(-1.25, 1.25), y = c(-1.25, 1.25))
p2
# ggsave("figures/g.png", p2, width=13.4, height=13.4)
# Chunk 19: models
model <- mgcv::gam(Result ~ s(Noise_Intensity, by = interaction(Index, Signal)),
data=df |>
filter(Index %in% selection) |>
mutate(Noise_Type = as.factor(Noise_Type)))
estimate_means(model, at = c("Index", "Signal", "Noise_Intensity")) |>
ggplot(aes(y = Mean, x = Noise_Intensity)) +
geom_line(aes(color = Signal), size=1) +
facet_wrap(~Index) +
scale_linetype_manual(values = c("-2" = 3, "-1" = 4, "0" = 2, "1" = 5, "2" = 1)) +
theme_classic() +
scale_color_material("rainbow") +
theme(panel.grid.major = element_line(colour = "#EEEEEE"),
strip.background = element_blank()) +
labs(y = "Standardized Index Value", x = "Noise Intensity", color = "Signal Type")
library(tidyverse)
library(easystats)
library(patchwork)
df <- read.csv("C:/Users/anshu.te/Documents/Github/NeuroKit/studies/complexity_benchmark/data_Signals.csv") |>
mutate(
Method = as.factor(Method),
Noise = as.factor(Noise),
Noise = fct_recode(Noise, "Violet" = "-2", "Blue" = "-1", "White" = "0", "Pink" = "1", "Brown" = "2"),
Intensity = as.factor(insight::format_value(Noise_Intensity))
)
df <- df |>
filter(Intensity %in% levels(df$Intensity)[c(1, round(length(levels(df$Intensity)) / 3), length(levels(df$Intensity)))])
make_plot <- function(method = "Random-Walk", title = "Random-Walk", color = "red") {
df |>
filter(Method == method) |>
ggplot(aes(x = Duration, y = Signal)) +
geom_line(color = color, size=0.3) +
ggside::geom_ysidedensity(aes(x = stat(density))) +
facet_grid(Intensity ~ Noise, labeller = label_value) +
labs(y = NULL, title = title, x = NULL) +
theme_minimal() +
theme(
axis.ticks = element_blank(),
axis.text = element_blank(),
plot.title = element_text(hjust = 0.5),
ggside.panel.border = element_blank(),
ggside.panel.grid = element_blank(),
ggside.panel.background = element_blank()
)
}
p1 <- make_plot(method = "Random-Walk", title = "Random-Walk", color = "#795548")
p2 <- make_plot(method = "lorenz_10_2.5_28", title = "Lorenz (/u03c3=10, \u03B2=2.5, \u03C1=28)", color = "#FF5722")
p3 <- make_plot(method = "lorenz_20_2_30", title = "Lorenz (\u03c3=20, \u03B2=2, \u03C1=30)", color = "#E91E63")
p4 <- make_plot(method = "oscillatory", title = "Oscillatory", color = "#2196F3")
p5 <- make_plot(method = "fractal", title = "Fractal", color = "#4CAF50")
p1 / p2 / p3 / p4 / p5 + patchwork::plot_annotation(title = "Examples of Simulated Signals", theme = theme(plot.title = element_text(face = "bold", hjust = 0.5)))
rm(df, p1, p2, p3, p4, p5)
48*5*5*5
df <- read.csv("C:/Users/anshu.te/Documents/Github/NeuroKit/studies/complexity_benchmark/data_Complexity.csv") |>
mutate(Method = as.factor(Method))
colors <- c(
"SD" = "red",
"Noise" = "red",
"Length" = "red",
"Random" = "red",
"Frequency" = "red",
"PFD (A)" = "#2196F3",
"PFD (B)" = "#2196F3",
"PFD (C)" = "#2196F3",
"PFD (D)" = "#2196F3",
"PFD (r)" = "#2196F3",
"PFD (3)" = "#2196F3",
"PFD (10)" = "#2196F3",
"PFD (100)" = "#2196F3",
"PFD (1000)" = "#2196F3",
"KFD" = "#2196F3",
"SFD" = "#2196F3",
"SDAFD" = "#2196F3",
"NLDFD" = "#2196F3",
"PSDFD (Voss1998)" = "#2196F3",
"PSDFD (Hasselman2013)" = "#2196F3",
"HFD" = "#2196F3",
"SVDEn" = "#E91E63",
"K2En" = "#E91E63",
"AttEn" = "#E91E63",
"PhasEn (4)" = "#E91E63",
"PhasEn (8)" = "#E91E63",
"GridEn (3)" = "#E91E63",
"GridEn (10)" = "#E91E63",
"DiffEn" = "#E91E63",
"DistrEn" = "#E91E63",
"ApEn" = "#E91E63",
"cApEn" = "#E91E63",
"PEn" = "#E91E63",
"WPEn" = "#E91E63",
"SampEn" = "#E91E63",
"FuzzyEn" = "#E91E63",
"FuzzyApEn" = "#E91E63",
"FuzzycApEn" = "#E91E63",
"MSEn" = "#E91E63",
"CMSEn" = "#E91E63",
"RCMSEn" = "#E91E63",
"MMSEn" = "#E91E63",
"IMSEn" = "#E91E63",
"MSApEn" = "#E91E63",
"MSPEn" = "#E91E63",
"CMSPEn" = "#E91E63",
"MMSPEn" = "#E91E63",
"IMSPEn" = "#E91E63",
"MSWPEn" = "#E91E63",
"CMSWPEn" = "#E91E63",
"MMSWPEn" = "#E91E63",
"IMSWPEn" = "#E91E63",
"CPEn" = "#E91E63",
"CWPEn" = "#E91E63",
"CRPEn" = "#E91E63",
"BubbEn" = "#E91E63",
"CoSiEn" = "#E91E63",
"MSCoSiEn" = "#E91E63",
"IncrEn" = "#E91E63",
"MSIncrEn" = "#E91E63",
"SlopEn" = "#E91E63",
"SlopEn (7)" = "#E91E63",
"MSSlopEn" = "#E91E63",
"SyDyEn" = "#E91E63",
"MSSyDyEn" = "#E91E63",
"MMSyDyEn" = "#E91E63",
"DispEn" = "#E91E63",
"DispEn (fluctuation)" = "#E91E63",
"FuzzyMSEn" = "#E91E63",
"FuzzyCMSEn" = "#E91E63",
"FuzzyRCMSEn" = "#E91E63",
"FuzzyMMSEn" = "#E91E63",
"FuzzyIMSEn" = "#E91E63",
"ShanEn (A)" = "#E91E63",
"ShanEn (B)" = "#E91E63",
"ShanEn (C)" = "#E91E63",
"ShanEn (D)" = "#E91E63",
"ShanEn (r)" = "#E91E63",
"ShanEn (3)" = "#E91E63",
"ShanEn (10)" = "#E91E63",
"ShanEn (100)" = "#E91E63",
"ShanEn (1000)" = "#E91E63",
"CREn (A)" = "#E91E63",
"CREn (B)" = "#E91E63",
"CREn (C)" = "#E91E63",
"CREn (D)" = "#E91E63",
"CREn (r)" = "#E91E63",
"CREn (3)" = "#E91E63",
"CREn (10)" = "#E91E63",
"CREn (100)" = "#E91E63",
"CREn (1000)" = "#E91E63",
"EnofEn (3)" = "#E91E63",
"EnofEn (5)" = "#E91E63",
"EnofEn (9)" = "#E91E63",
"RangeEn" = "#E91E63",
"SPEn (10)" = "#E91E63",
"SPEn (50)" = "#E91E63",
"SPEn (100)" = "#E91E63",
"HEn" = "#E91E63",
"KLEn" = "#E91E63",
"KLEn (corrected)" = "#E91E63",
"H" = "#2196F3",
"LZC" = "#2196F3",
"PLZC" = "#2196F3",
"MSLZC" = "#2196F3",
"MSPLZC" = "#2196F3",
"RR" = "#2196F3",
"FI" = "#FF5722",
"FSI" = "#FF5722",
"PowEn" = "#FF5722",
"CD" = "#FF5722",
"Hjorth" = "#FF5722",
"LLE" = "#2196F3",
"RQA (RecurrenceRate)" = "#4CAF50",
"RQA (Determinism)" = "#4CAF50",
"RQA (Laminarity)" = "#4CAF50",
"RQA (TrappingTime)" = "#4CAF50",
"RQA (DeteRec)" = "#4CAF50",
"RQA (Divergence)" = "#4CAF50",
"RQA (LamiDet)" = "#4CAF50",
"RQA (L)" = "#4CAF50",
"RQA (LEn)" = "#4CAF50",
"RQA (VMax)" = "#4CAF50",
"RQA (VEn)" = "#4CAF50",
"RQA (W)" = "#4CAF50",
"RQA (WMax)" = "#4CAF50",
"RQA (WEn)" = "#4CAF50",
"DFA" = "#4CAF50",
"MFDFA (Fluctuation)" = "#4CAF50",
"MFDFA (Width)" = "#4CAF50",
"MFDFA (Peak)" = "#4CAF50",
"MFDFA (Mean)" = "#4CAF50",
"MFDFA (Max)" = "#4CAF50",
"MFDFA (Delta)" = "#4CAF50",
"MFDFA (Asymmetry)" = "#4CAF50",
"MFDFA (Increment)" = "#4CAF50"
)
# length(unique(df$Index))
# unique(df$Index)[!unique(df$Index) %in% names(colors)]
# names(colors)[!names(colors) %in% unique(df$Index)]
order <- df |>
group_by(Index) |>
summarize(Duration = median(Duration)) |>
arrange(Duration) |>
mutate(Index = factor(Index, levels = Index))
df <- mutate(df, Index = fct_relevel(Index, as.character(order$Index)))
p <- df |>
filter(!Index %in% c("SD", "Length", "Noise", "Random", "Frequency")) |>
mutate(Duration = Duration * 10000) |>
ggplot(aes(x = Index, y = Duration)) +
# geom_violin(aes(fill = Index)) +
geom_hline(yintercept = 10**seq(0, 5, by = 2), linetype = "dotted", color = "#9E9E9E") +
geom_hline(yintercept = 10**seq(1, 5, by = 2), color = "#9E9E9E") +
ggdist::stat_slab(side = "bottom", aes(fill = Index), adjust = 3) +
ggdist::stat_dotsinterval(aes(fill = Index, slab_size = NA)) +
theme_modern() +
scale_y_log10(breaks = 10**seq(0, 5), labels = function(x) sprintf("%g", x)) +
scale_fill_manual(values = colors, guide = "none") +
theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust = 1)) +
labs(x = NULL, y = "Computation Time")
# ggsave("figures/computation_time-1.png", p, height=10*1.25, width=16*1.25)
p
# Show and filter out NaNs
as.character(df[is.na(df$Result), "Index"])
df <- filter(df, !is.na(Result))
as.character(df[is.infinite(df$Result), "Index"])
df <- filter(df, !is.infinite(Result))
df <- df |>
group_by(Index) |>
standardize(select = "Result") |>
ungroup()
# Duplicates
# ===========
averagetime <- arrange(summarize(group_by(df, Index), Duration = mean(Duration)), Duration)
filter(averagetime, Index %in% c("CREn (D)", "PFD (D)", "ShanEn (D)"))
filter(averagetime, Index %in% c("ShanEn (B)", "CREn (B)"))
filter(averagetime, Index %in% c("ShanEn (r)", "PFD (r)", "CREn (r)"))
filter(averagetime, Index %in% c("ShanEn (C)", "PFD (C)", "CREn (C)"))
filter(averagetime, Index %in% c("CREn (10)", "CREn (100)"))
filter(averagetime, Index %in% c("SVDEn", "FI"))
filter(averagetime, Index %in% c("PSDFD (Hasselman2013)", "PSDFD (Voss1998)"))
filter(averagetime, Index %in% c("MMSEn", "IMSEn"))
filter(averagetime, Index %in% c("H (corrected)", "H (uncorrected)"))
filter(averagetime, Index %in% c("FuzzyEn", "FuzzyApEn"))
filter(averagetime, Index %in% c("RCMSEn", "FuzzyRCMSEn"))
filter(averagetime, Index %in% c("SVDEn", "FuzzycApEn"))
filter(averagetime, Index %in% c("CPEn", "CRPEn"))
filter(averagetime, Index %in% c("NLDFD", "RR"))
data <- data |>
select(
-`FuzzyRCMSEn`,
-`CREn (100)`,
-`PowEn`
)
cor <- get_cor(data, plot=TRUE)
p <- df |>
filter(!Index %in% c("SD", "Length", "Noise", "Random", "Frequency")) |>
mutate(Duration = Duration * 10000) |>
ggplot(aes(x = Index, y = Duration)) +
# geom_violin(aes(fill = Index)) +
geom_hline(yintercept = 10**seq(0, 5, by = 2), linetype = "dotted", color = "#9E9E9E") +
geom_hline(yintercept = 10**seq(1, 5, by = 2), color = "#9E9E9E") +
ggdist::stat_slab(side = "bottom", aes(fill = Index), adjust = 3) +
ggdist::stat_dotsinterval(aes(fill = Index, slab_size = NA)) +
theme_modern() +
scale_y_log10(breaks = 10**seq(0, 5), labels = function(x) sprintf("%g", x)) +
scale_fill_manual(values = colors, guide = "none") +
theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust = 1)) +
labs(x = NULL, y = "Computation Time")
# ggsave("figures/computation_time-1.png", p, height=10*1.25, width=16*1.25)
p
